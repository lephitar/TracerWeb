<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracer Token Interface</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;400;700&family=Open+Sans:wght@300;400;500;600&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.1/ethers.umd.min.js"></script>
    <style>
        :root {
            --primary-blue: #2c59fb;
            --bg-light: #f5f7ff;
            --bg-medium: #e8edff;
            --bg-dark: #dde5ff;
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --text-light: #718096;
            --card-bg: #ffffff;
            --shadow: rgba(44, 89, 251, 0.1);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Open Sans', sans-serif;
            font-weight: 400;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-medium) 50%, var(--bg-dark) 100%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 20px 40px var(--shadow);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'Comfortaa', sans-serif;
            font-weight: 700;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            color: var(--primary-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .logo {
            width: 60px;
            height: 60px;
            /*                   border-radius: 50%;
 */
            box-shadow: 0 8px 16px var(--shadow);
        }

        h3 {
            font-family: 'Comfortaa', sans-serif;
            font-weight: 600;
            margin-top: 0;
            color: var(--primary-blue);
        }

        footer {
            font-family: 'Open Sans', sans-serif;
            text-align: center;
            padding: 30px 20px;
            margin-top: 40px;
            color: var(--text-light);
            font-size: 14px;
        }


        .status {
            padding: 16px 24px;
            border-radius: 50px;
            margin-bottom: 30px;
            font-weight: 600;
            text-align: center;
            font-family: 'Comfortaa', sans-serif;
        }

        .status.connected {
            background: linear-gradient(135deg, #7FB800, #608B00);
            color: white;
            box-shadow: 0 8px 16px rgba(16, 185, 129, 0.3);
        }

        .status.disconnected {
            background: linear-gradient(135deg, #f6511d, #BD3E16);
            color: white;
            box-shadow: 0 8px 16px rgba(239, 68, 68, 0.3);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            margin-bottom: 40px;
        }

        .info-card {
            background: var(--card-bg);
            padding: 24px;
            border-radius: 20px;
            box-shadow: 0 8px 20px var(--shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .info-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 28px var(--shadow);
        }

        .actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        button {
            font-family: 'Comfortaa', cursive;
            font-weight: 600;
            background: linear-gradient(135deg, var(--primary-blue), #1e40af);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 16px rgba(44, 89, 251, 0.3);
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(44, 89, 251, 0.4);
            background: linear-gradient(135deg, #1e40af, var(--primary-blue));
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            background: linear-gradient(135deg, var(--text-light), #9ca3af);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 8px rgba(113, 128, 150, 0.2);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .input-group input {
            width: 100%;
            padding: 16px 24px;
            border: 2px solid var(--bg-medium);
            border-radius: 50px;
            background: var(--card-bg);
            color: var(--text-primary);
            font-size: 16px;
            font-family: 'Open Sans', sans-serif;
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(44, 89, 251, 0.1);
        }

        .input-group input::placeholder {
            color: var(--text-light);
        }

        .transaction-section {
            background: var(--card-bg);
            padding: 32px;
            border-radius: 24px;
            margin-bottom: 24px;
            box-shadow: 0 8px 20px var(--shadow);
        }

        .transaction-section h3 {
            margin-top: 0;
            color: var(--primary-blue);
            padding-bottom: 16px;
            border-bottom: 2px solid var(--bg-medium);
            margin-bottom: 24px;
        }

        .contract-info {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: var(--bg-light);
            color: var(--text-secondary);
            padding: 16px;
            border-radius: 12px;
            word-break: break-all;
            border: 1px solid var(--bg-medium);
            overflow-wrap: break-word;
        }

        .error {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            border: 2px solid #f87171;
            color: #991b1b;
            padding: 20px;
            border-radius: 20px;
            margin: 20px 0;
            font-weight: 500;
            overflow-wrap: break-word;

        }

        .success {
            background: linear-gradient(135deg, #dcfce7, #bbf7d0);
            border: 2px solid #34d399;
            color: #065f46;
            padding: 20px;
            border-radius: 20px;
            margin: 20px 0;
            font-weight: 500;

            white-space: normal;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .notice {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px solid #f59e0b;
            color: #92400e;
            padding: 20px;
            border-radius: 20px;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 500;
        }

        .notice code {
            background: rgba(146, 64, 14, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }

        @media (max-width: 768px) {
            .container {
                padding: 24px;
            }

            h1 {
                font-size: 2em;
                flex-direction: column;
                gap: 10px;
            }

            .logo {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>
            <img src="tracericon.svg" alt="Tracer Logo" class="logo">
            Tracer Token Dashboard
        </h1>

        <div class="notice">
            <strong>‚ö†Ô∏è Early prototype:</strong> Connect your wallet with MetaMask (works with Ledger Nano) to view your
            TRCR tokens. Contact support if you experience any problems üòÇ.
        </div>

        <div id="status" class="status disconnected">
            Not Connected to MetaMask
        </div>

        <div class="info-grid">
            <div class="info-card">
                <h3>Network</h3>
                <div id="network">Auto-detect from MetaMask</div>
            </div>

            <div class="info-card">
                <h3>Contract Address</h3>
                <div class="contract-info" id="contractAddress">
                    0x23fd096B2875A6dEccae8C688f44fAf0001E3Eef</div>
            </div>

            <div class="info-card">
                <h3>Total Supply</h3>
                <div id="totalSupply">Loading...</div>
                <div id="symbol"></div>
            </div>

            <div class="info-card">
                <h3>Your Address</h3>
                <div class="contract-info" id="userAddress">Not Connected</div>
            </div>

            <div class="info-card">
                <h3>Your Balance</h3>
                <div id="balance"></div>
                <div id="symbol"></div>
            </div>

            <div class="info-card">
                <h3>Permit Counter</h3>
                <div id="nonce"></div>
            </div>

            <div class="info-card">
                <h3>Your Voting Power</h3>
                <div id="votingPower">Loading...</div>
                <div id="symbol"></div>
            </div>

            <div class="info-card">
                <h3>Voting Power Holder</h3>
                <div id="delegates">Loading...</div>
            </div>

        </div>

        <div class="actions">
            <button id="connectBtn" onclick="connectWallet()">Connect MetaMask</button>
            <button id="refreshBtn" onclick="refreshData()" disabled>Refresh Data</button>
            <button onclick="addToMetaMask()" disabled id="addTokenBtn">Add Tracer to MetaMask</button>
        </div>

        <div class="transaction-section">
            <h3>Transfer Tokens</h3>
            <div class="input-group">
                <label for="transferTo">Recipient Address:</label>
                <input type="text" id="transferTo" placeholder="0x..." />
            </div>
            <div class="input-group">
                <label for="transferAmount">Amount (TRCR):</label>
                <input type="number" id="transferAmount" placeholder="0.0" step="0.000000000000000001" />
            </div>
            <button onclick="transferTokens()" disabled id="transferTokensBtn">Transfer</button>
            <div id="transferTokensResult"></div>
        </div>

        <div class="transaction-section">
            <h3>Approve Allowance</h3>
            <div class="input-group">
                <label for="approveSpender">Spender Address:</label>
                <input type="text" id="approveSpender" placeholder="0x..." />
            </div>
            <div class="input-group">
                <label for="approveAmount">Amount (TRCR):</label>
                <input type="number" id="approveAmount" placeholder="0.0" step="0.000000000000000001" />
            </div>
            <button onclick="approveTokens()" disabled id="approveTokensBtn">Approve</button>
            <div id="approveTokensResult"></div>
        </div>

        <div class="transaction-section">
            <h3>Check Allowance</h3>
            <div class="input-group">
                <label for="allowanceOwner">Owner Address:</label>
                <input type="text" id="allowanceOwner" placeholder="0x... (leave empty for your address)" />
            </div>
            <div class="input-group">
                <label for="allowanceSpender">Spender Address:</label>
                <input type="text" id="allowanceSpender" placeholder="0x..." />
            </div>
            <button onclick="checkAllowance()" disabled id="checkAllowanceBtn">Check Allowance</button>
            <div id="checkAllowanceResult"></div>
        </div>

        <div class="transaction-section">
            <h3>Permit via Signature</h3>
            <div class="input-group">
                <label for="permitSpenderAddress">Permit Spender:</label>
                <input type="text" id="permitSpenderAddress" placeholder="0x..." type="text" />
            </div>
            <div class="input-group">
                <label for="permitAmount">Amount: (TRCR)</label>
                <input type="text" id="permitAmount" placeholder="0.0" type="text" />
            </div>
            <div class="input-group">
                <label for="deadlineStr">Deadline (local time):</label>
                <input type="text" id="deadlineStr" type="datetime-local" />
            </div>

            <button onclick="signAndSubmitPermit()" disabled id="signAndSubmitPermitBtn">Sign & Sumbit</button>
            <div id="signAndSubmitPermitResult"></div>
        </div>

        <div class="transaction-section">
            <h3>Check Voting Power</h3>
            <div class="input-group">
                <label for="votingPowerAddress">Address:</label>
                <input type="text" id="votingPowerAddress" placeholder="0x... (leave empty for your address)" />
            </div>
            <button onclick="checkVotingPower()" disabled id="checkVotingPowerBtn">Check Voting Power</button>
            <div id="checkVotingPowerResult"></div>
        </div>

        <div class="transaction-section">
            <h3>Delegate Voting Power</h3>
            <div class="input-group">
                <label for="delegateAddress">Delegatee Address:</label>
                <input type="text" id="delegateAddress" placeholder="0x... (leave empty to delegate to self)" />
            </div>
            <button onclick="delegateVotingPower()" disabled id="delegateVotingPowerBtn">Delegate</button>
            <div id="delegateVotingPowerResult"></div>
        </div>

        <div id="messages"></div>
    </div>

    <footer>
        ¬© 2025 Tracer. All rights reserved. Use at your own risk.
    </footer>

    <script>
        // Contract configuration - both networks
        const CONTRACTS = {
            421614: { // Arbitrum Sepolia
                address: '0x23fd096B2875A6dEccae8C688f44fAf0001E3Eef',
                name: 'Arbitrum Sepolia',
                chainIdHex: '0x66eee',
                rpcUrl: 'https://sepolia-rollup.arbitrum.io/rpc',
                blockExplorer: 'https://sepolia.arbiscan.io/',
                nativeCurrency: {
                    name: 'Arbitrum Sepolia Ether',
                    symbol: 'ETH',
                    decimals: 18
                }
            },
            42161: { // Arbitrum One (Mainnet)
                address: '0x0000000000000000000000000000000000000000', // Replace with actual mainnet address
                name: 'Arbitrum One',
                chainIdHex: '0xa4b1',
                rpcUrl: 'https://arb1.arbitrum.io/rpc',
                blockExplorer: 'https://arbiscan.io/',
                nativeCurrency: {
                    name: 'Ether',
                    symbol: 'ETH',
                    decimals: 18
                }
            }
        };

        let currentNetwork = null;
        let contractAddress = null;
        // ERC20 ABI with ERC20Votes and ERC20Permit functions
        const TOKEN_ABI = [
            // Standard ERC20
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function totalSupply() view returns (uint256)",
            "function balanceOf(address owner) view returns (uint256)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function transferFrom(address from, address to, uint256 amount) returns (bool)",

            // ERC20Permit
            "function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)",
            "function nonces(address owner) view returns (uint256)",
            "function DOMAIN_SEPARATOR() view returns (bytes32)",

            // ERC20Votes
            "function getVotes(address account) view returns (uint256)",
            "function getPastVotes(address account, uint256 blockNumber) view returns (uint256)",
            "function getPastTotalSupply(uint256 blockNumber) view returns (uint256)",
            "function delegate(address delegatee)",
            "function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)",
            "function delegates(address account) view returns (address)",
            "function checkpoints(address account, uint32 pos) view returns (tuple(uint32 fromBlock, uint224 votes))",
            "function numCheckpoints(address account) view returns (uint32)",

            // Events
            "event Transfer(address indexed from, address indexed to, uint256 value)",
            "event Approval(address indexed owner, address indexed spender, uint256 value)",
            "event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)",
            "event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance)"
        ];

        let provider, signer, contract, userAccount;

        function detectNetwork(chainId) {
            const networkId = parseInt(chainId);
            currentNetwork = CONTRACTS[networkId];

            if (currentNetwork) {
                contractAddress = currentNetwork.address;
                document.getElementById('network').textContent = currentNetwork.name;
                document.getElementById('contractAddress').innerHTML = explorerLink('address', currentNetwork.address);
                return true;
            } else {
                currentNetwork = null;
                contractAddress = null;
                return false;
            }
        }

        function updateNetworkUI() {
            if (currentNetwork) {
                document.getElementById('network').textContent = currentNetwork.name;
                document.getElementById('contractAddress').innerHTML = explorerLink('address', currentNetwork.address);

                // Show/hide mainnet warning
                const isMainnet = currentNetwork.name === 'Arbitrum One';
                let warning = document.getElementById('mainnetWarning');

                if (isMainnet && contractAddress === '0x0000000000000000000000000000000000000000') {
                    if (!warning) {
                        warning = document.createElement('div');
                        warning.id = 'mainnetWarning';
                        warning.className = 'error';
                        warning.innerHTML = '<strong>‚ö†Ô∏è Mainnet Warning:</strong> Please update the mainnet contract address in the code before using on Arbitrum One.';
                        document.querySelector('.container').insertBefore(warning, document.getElementById('status'));
                    }
                } else if (warning) {
                    warning.remove();
                }
            }
        }

        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    showMessage('MetaMask is not installed!', 'error');
                    return;
                }
                // Ensure MetaMask is fully loaded
                await new Promise(resolve => {
                    if (document.readyState === 'complete') {
                        resolve();
                    } else {
                        window.addEventListener('load', resolve, { once: true });
                    }
                });

                // Request account access with additional options for file:// protocol
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts',
                    params: []
                });

                if (!accounts || accounts.length === 0) {
                    throw new Error('No accounts found. Please unlock MetaMask.');
                }

                // Initialize ethers provider
                provider = new ethers.BrowserProvider(window.ethereum);

                // Wait for provider to be ready
                await provider._detectNetwork();

                // Get current network
                const network = await provider.getNetwork();
                const isSupported = detectNetwork(network.chainId.toString());

                if (!isSupported) {
                    showMessage(`Unsupported network. Please switch to Arbitrum One or Arbitrum Sepolia.`, 'error');
                    updateNetworkUI();
                    return;
                }

                signer = await provider.getSigner();
                userAccount = await signer.getAddress();

                // Initialize contract with current network
                contract = new ethers.Contract(contractAddress, TOKEN_ABI, signer);

                document.getElementById('checkVotingPowerBtn').disabled = false;
                document.getElementById('delegateVotingPowerBtn').disabled = false;
                document.getElementById('signAndSubmitPermitBtn').disabled = false;
                document.getElementById('deadlineStr').value = getLocalDeadline(120);

                updateUI();

                updateNetworkUI();

                await refreshData();

                showMessage(`Successfully connected to ${currentNetwork.name}!`, 'success');

            } catch (error) {
                console.error('Connection error:', error);

                // Handle specific MetaMask errors
                if (error.code === 4001) {
                    showMessage('Connection cancelled by user', 'error');
                } else if (error.code === -32002) {
                    showMessage('Connection request already pending in MetaMask', 'error');
                } else if (error.message.includes('origin')) {
                    showMessage('MetaMask origin error. Try refreshing the page or using a local server.', 'error');
                } else {
                    showMessage(`Connection failed: ${error.message}`, 'error');
                }
            }
        }

        function updateUI() {
            if (userAccount) {
                document.getElementById('status').textContent = 'Connected to MetaMask';
                document.getElementById('status').className = 'status connected';
                document.getElementById('userAddress').innerHTML = explorerLink('address', userAccount);
                // Enable buttons
                const buttons = ['refreshBtn', 'transferTokensBtn', 'approveTokensBtn', 'checkAllowanceBtn', 'signAndSubmitPermitBtn', 'checkVotingPowerBtn', 'delegateVotingPowerBtn', 'addTokenBtn'];
                buttons.forEach(id => document.getElementById(id).disabled = false);

                document.getElementById('connectBtn').textContent = 'Connected';
                document.getElementById('connectBtn').disabled = true;
            }
        }

        async function refreshData() {
            if (!contract || !userAccount) return;

            try {
                // Get token info
                const [balance, totalSupply, nonce, name, symbol, decimals, votingPower, delegates] = await Promise.all([
                    contract.balanceOf(userAccount),
                    contract.totalSupply(),
                    contract.nonces(userAccount),
                    contract.name(),
                    contract.symbol(),
                    contract.decimals(),
                    contract.getVotes(userAccount),
                    contract.delegates(userAccount)
                ]);

                // Format and display
                const formattedBalance = ethers.formatUnits(balance, decimals);
                const formattedTotalSupply = ethers.formatUnits(totalSupply, decimals);
                const formattedVotingPower = ethers.formatUnits(votingPower, decimals);

                document.getElementById('balance').textContent = `${parseFloat(formattedBalance).toLocaleString()} ${symbol}`;
                document.getElementById('totalSupply').textContent = `${parseFloat(formattedTotalSupply).toLocaleString()} ${symbol}`;
                document.getElementById('nonce').textContent = nonce.toString();
                document.getElementById('votingPower').textContent = `${parseFloat(formattedVotingPower).toLocaleString()} ${symbol}`;

                const el = document.getElementById("delegates");

                let displayDelegate;
                if (delegates === ethers.ZeroAddress) {
                    displayDelegate = "No delegate set";
                } else if (delegates.toLowerCase() === userAccount.toLowerCase()) {
                    displayDelegate = "Self-delegated";
                } else {
                    displayDelegate = delegates;
                }
                el.textContent = displayDelegate;
                // Toggle the class only if it's an address
                if (ethers.isAddress(displayDelegate)) {
                    el.classList.add("contract-info");
                } else {
                    el.classList.remove("contract-info");
                }

                showMessage('Data refreshed successfully!', 'success');
            } catch (error) {
                console.error('Refresh error:', error);
                showMessage(`Failed to refresh data: ${error.message}`, 'error');
            }
        }

        /**
 * Creates an HTML link to a blockchain explorer for a transaction, address, or contract.
 * @param {string} type - "tx" for transaction, "address" for wallet/contract.
 * @param {string} value - Transaction hash or address.
 * @param {number|string} chainId - The current chain ID.
 * @param {string} [label] - Optional label for the link text (defaults to value).
 * @returns {string} HTML string with link or plain text fallback.
 */
        function explorerLink(type, value, label) {
            const explorer = currentNetwork.blockExplorer;
            const text = label || value;

            if (!explorer || !value) {
                return `<code>${text}</code>`;
            }

            // Normalize type to path
            let path = '';
            if (type === 'tx') {
                path = `tx/${value}`;
                return `<code><a href="${explorer}${path}" target="_blank" rel="noopener">${text}</a></code>`;

            } else if (type === 'address') {
                path = `address/${value}`;
                return `<code><a style="cursor: pointer;" href="${explorer}${path}" target="_blank" rel="noopener">${text}</a></code>`;

            } else {
                console.warn('Unknown explorer link type:', type);
                return `<code>${text}</code>`;
            }

        }

        async function transferTokens() {
            const to = document.getElementById('transferTo').value;
            const amount = document.getElementById('transferAmount').value;

            if (!to || !amount) {
                showMessage('Please fill in all fields', 'error');
                return;
            }

            try {
                const decimals = await contract.decimals();
                const amountWei = ethers.parseUnits(amount, decimals);

                showMessage('Transaction pending... Please confirm in MetaMask', 'info');
                const tx = await contract.transfer(to, amountWei);

                showMessage('Transaction submitted! Waiting for confirmation...', 'success');
                await tx.wait();
                await refreshData();

                document.getElementById('transferTokensResult').innerHTML = `
                            <div class="success">
                                Transfer successul to ${explorerLink('address', to)}<br/>
                                TX Hash: ${explorerLink('tx', tx.hash)}
                            </div>
                       `;

                // Clear inputs
                document.getElementById('transferTo').value = '';
                document.getElementById('transferAmount').value = '';

            } catch (error) {
                console.error('Transfer error:', error);
                showMessage(`Transfer failed: ${error.message}`, 'error');
            }
        }

        async function approveTokens() {
            const spender = document.getElementById('approveSpender').value;
            const amount = document.getElementById('approveAmount').value;

            if (!spender || !amount) {
                showMessage('Please fill in all fields', 'error');
                return;
            }

            try {
                const decimals = await contract.decimals();
                const amountWei = ethers.parseUnits(amount, decimals);

                showMessage('Transaction pending... Please confirm in MetaMask', 'info');
                const tx = await contract.approve(spender, amountWei);

                showMessage('Transaction submitted! Waiting for confirmation...', 'success');
                await tx.wait();
                await refreshData();

                document.getElementById('approveTokensResult').innerHTML = `
                            <div class="success">
                                Approval successul to ${explorerLink('address', spender)}<br/>
                                TX Hash: ${explorerLink('tx', tx.hash)}
                            </div>
                       `;

                // Clear inputs
                document.getElementById('approveSpender').value = '';
                document.getElementById('approveAmount').value = '';

            } catch (error) {
                console.error('Approval error:', error);
                showMessage(`Approval failed: ${error.message}`, 'error');
            }
        }

        async function checkAllowance() {
            const owner = document.getElementById('allowanceOwner').value || userAccount;
            const spender = document.getElementById('allowanceSpender').value;

            if (!spender) {
                showMessage('Please enter spender address', 'error');
                return;
            }

            try {
                const allowance = await contract.allowance(owner, spender);
                const decimals = await contract.decimals();
                const symbol = await contract.symbol();
                const formattedAllowance = ethers.formatUnits(allowance, decimals);

                document.getElementById('checkAllowanceResult').innerHTML = `
                    <div class="success">
                        Allowance: ${parseFloat(formattedAllowance).toLocaleString()} ${symbol}
                    </div>
                `;
            } catch (error) {
                console.error('Allowance check error:', error);
                showMessage(`Failed to check allowance: ${error.message}`, 'error');
            }
        }

        async function delegateVotingPower() {
            const delegatee = document.getElementById('delegateAddress').value || userAccount;

            if (!ethers.isAddress(delegatee)) {
                showMessage('Invalid delegatee address', 'error');
                return;
            }

            try {
                document.getElementById('delegateVotingPowerBtn').disabled = true;
                showMessage('Sending delegation transaction...', 'info');

                const tx = await contract.delegate(delegatee);
                await tx.wait();

                await refreshData();

                document.getElementById('delegateVotingPowerResult').innerHTML = `
            <div class="success">
                Successfully delegated to ${explorerLink('address', delegatee)}<br>
                Tx Hash: ${explorerLink('tx', tx.hash)}

            </div>
        `;
                showMessage('Delegation successful!', 'success');
            } catch (error) {
                console.error('Delegation error:', error);
                showMessage(`Delegation failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('delegateVotingPowerBtn').disabled = false;
            }
        }

        async function checkVotingPower() {
            const address = document.getElementById('votingPowerAddress').value || userAccount;

            if (!ethers.isAddress(address)) {
                showMessage('Invalid address', 'error');
                return;
            }

            try {
                document.getElementById('checkVotingPowerBtn').disabled = true;
                showMessage('Fetching voting power...', 'info');

                const votes = await contract.getVotes(address);
                const decimals = await contract.decimals();
                const symbol = await contract.symbol();
                const formattedVotes = ethers.formatUnits(votes, decimals);

                document.getElementById('checkVotingPowerResult').innerHTML = `
            <div class="success">
                Voting Power: ${parseFloat(formattedVotes).toLocaleString()} ${symbol}
            </div>
        `;
                showMessage('Voting power retrieved!', 'success');
            } catch (error) {
                console.error('Voting power error:', error);
                showMessage(`Failed to fetch voting power: ${error.message}`, 'error');
            } finally {
                document.getElementById('checkVotingPowerBtn').disabled = false;
            }
        }

        async function signAndSubmitPermit() {
            const spender = document.getElementById('permitSpenderAddress').value.trim();
            const amountStr = document.getElementById('permitAmount').value.trim();
            const deadlineStr = document.getElementById('deadlineStr').value.trim(); // <input type="datetime-local">

            // Basic validations
            if (!ethers.isAddress(spender)) {
                showMessage('Invalid permit spender address', 'error');
                return;
            }
            if (!amountStr || isNaN(Number(amountStr)) || Number(amountStr) <= 0) {
                showMessage('Enter a valid amount', 'error');
                return;
            }
            if (!deadlineStr) {
                showMessage('Please choose a deadline (date & time)', 'error');
                return;
            }

            try {
                // Disable button + info
                const btn = document.getElementById('signAndSubmitPermitBtn');
                btn.disabled = true;
                showMessage('Signing permit and sending transaction‚Ä¶', 'info');

                // Gather data
                const [decimals, name, tokenAddress, nonce, network] = await Promise.all([
                    contract.decimals(),
                    contract.name(),
                    contract.getAddress(),
                    contract.nonces(userAccount),
                    provider.getNetwork()
                ]);

                const value = ethers.parseUnits(amountStr, decimals);

                // Convert local datetime to UNIX seconds
                const deadlineMs = new Date(deadlineStr).getTime();
                if (Number.isNaN(deadlineMs)) {
                    showMessage('Invalid deadline format', 'error');
                    btn.disabled = false;
                    return;
                }
                const deadline = Math.floor(deadlineMs / 1000);
                const nowSec = Math.floor(Date.now() / 1000);
                console.log(deadline);
                console.log(nowSec);

                if (deadline <= nowSec) {
                    showMessage('Deadline must be in the future', 'error');
                    btn.disabled = false;
                    return;
                }

                // EIP-712 domain/types/message
                const domain = {
                    name,
                    version: '1', // OpenZeppelin ERC20Permit default
                    chainId: Number(network.chainId),
                    verifyingContract: tokenAddress
                };

                const types = {
                    Permit: [
                        { name: 'owner', type: 'address' },
                        { name: 'spender', type: 'address' },
                        { name: 'value', type: 'uint256' },
                        { name: 'nonce', type: 'uint256' },
                        { name: 'deadline', type: 'uint256' }
                    ]
                };

                const message = {
                    owner: userAccount,
                    spender,
                    value,
                    nonce,
                    deadline
                };

                // Ask wallet to sign typed data (EIP-712)
                const signature = await signer.signTypedData(domain, types, message);
                const { v, r, s } = ethers.Signature.from(signature);

                // Submit permit on-chain
                const tx = await contract.permit(userAccount, spender, value, deadline, v, r, s);
                showMessage('Transaction submitted! Waiting for confirmation...', 'success');

                await refreshData();
                await tx.wait();

                document.getElementById('signAndSubmitPermitResult').innerHTML = `
                            <div class="success">
                                Permit submitted successfully for ${explorerLink('address', spender)}<br/>
                                Tx Hash: ${explorerLink('tx', tx.hash)}
                            </div>
                       `;
                showMessage('Permit successful! Allowance has been set via signature.', 'success');
            } catch (error) {
                console.error('Permit error:', error);
                showMessage(`Permit failed: ${error.message} `, 'error');
            } finally {
                document.getElementById('signAndSubmitPermitBtn').disabled = false;
            }
        }

        async function addToMetaMask() {
            try {
                const [symbol, decimals] = await Promise.all([
                    contract.symbol(),
                    contract.decimals()
                ]);
                const tokenImageURL = 'https://tracer.endglobalwarming.net/tracerroundicon.svg';

                await window.ethereum.request({
                    method: 'wallet_watchAsset',
                    params: {
                        type: 'ERC20',
                        options: {
                            address: contractAddress,
                            symbol: symbol.toString(),
                            decimals: Number(decimals),
                            image: tokenImageURL,
                        },
                    },
                });

                showMessage('Token added to MetaMask!', 'success');
            } catch (error) {
                console.error('Add token error:', error);
                showMessage(`Failed to add token: ${error.message} `, 'error');
            }
        }

        function safeDelay(callback, ms = 0) {
            return new Promise(resolve => {
                const startTime = performance.now();
                function checkTime() {
                    if (performance.now() - startTime >= ms) {
                        callback();
                        resolve();
                    } else {
                        requestAnimationFrame(checkTime);
                    }
                }
                requestAnimationFrame(checkTime);
            });
        }

        function showMessage(message, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            messagesDiv.appendChild(messageDiv);

            // Remove message after 5 seconds
            safeDelay(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        /**
         * Returns a date string formatted for an <input type="datetime-local">,
         * set to a specified number of minutes in the future.
         * @param {number} minsFromNow - The number of minutes from now.
         * @returns {string} The formatted date string (e.g., "2025-08-15T16:21").
         */
        function getLocalDeadline(minsFromNow = 60) {
            // 1. Get the target date object
            const targetDate = new Date(Date.now() + minsFromNow * 60 * 1000);

            // 2. Use the built-in toISOString() method, which is the most reliable way
            //    It returns a UTC string like "2025-08-15T14:21:08.123Z"
            const isoString = targetDate.toISOString();

            // 3. Slice the string to get the "YYYY-MM-DDTHH:MM" part,
            //    which is exactly what the datetime-local input needs.
            return isoString.slice(0, 16);
        }


        // Listen for account changes with error handling
        if (typeof window.ethereum !== 'undefined') {
            // Wrap event listeners in try-catch to handle origin errors
            try {
                window.ethereum.on('accountsChanged', function (accounts) {
                    if (accounts.length === 0) {
                        location.reload();
                    } else {
                        requestAnimationFrame(() => connectWallet());
                    }
                });

                window.ethereum.on('chainChanged', function (chainId) {
                    // Detect new network and reconnect
                    requestAnimationFrame(async () => {
                        try {
                            await connectWallet();
                        } catch (error) {
                            location.reload();
                        }
                    });
                });
            } catch (error) {
                console.warn('Event listener setup failed:', error);
            }
        }

        // Auto-connect if previously connected
        window.addEventListener('load', async function () {
            await new Promise(resolve => {
                if (document.readyState === 'complete') {
                    resolve();
                } else {
                    window.addEventListener('load', resolve, { once: true });
                }
            });

            if (typeof window.ethereum !== 'undefined') {
                try {
                    // Check if MetaMask is unlocked and has connected accounts
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        // Use requestAnimationFrame for immediate but async execution
                        requestAnimationFrame(() => connectWallet());
                    }
                } catch (error) {
                    console.warn('Auto-connect check failed:', error);
                    // Don't show error message for auto-connect failures
                }
            } else {
                console.warn('MetaMask not detected on page load');
            }
        });
    </script>
</body>

</html>